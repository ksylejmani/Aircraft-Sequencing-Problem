// Generated by CoffeeScript 1.7.1
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

define(['external/react', 'external/underscore', 'modules/clean/activity/file_viewer_state', 'modules/clean/annotations/annotation', 'modules/clean/react/activity/like_bar', 'modules/clean/react/activity/resolve_button', 'modules/clean/react/activity/time_counter', 'modules/clean/react/modal', 'modules/core/i18n', 'modules/clean/viewer', 'modules/clean/avatar/components', 'modules/clean/referrer_cleansing_redirect', 'modules/clean/sticker_util', 'modules/clean/react/activity/annotation_button'], function(React, $u, FileViewerState, _arg, LikeBarClass, ResolveButtonClass, TimeCounterClass, _arg1, i18n, Viewer, _arg2, ReferrerCleansingRedirect, StickerUtil, AnnotationButtonClass) {
  var Annotation, AnnotationButton, AnnotationSubtypes, AnnotationTypes, AvatarWithDefault, CommentActivityUI, InitialsAvatar, LikeBar, ResolveButton, SimpleModal, TimeCounter, ViewerAvatar, d;
  Annotation = _arg.Annotation, AnnotationTypes = _arg.AnnotationTypes, AnnotationSubtypes = _arg.AnnotationSubtypes;
  SimpleModal = _arg1.SimpleModal;
  AvatarWithDefault = _arg2.AvatarWithDefault, InitialsAvatar = _arg2.InitialsAvatar, ViewerAvatar = _arg2.ViewerAvatar;
  d = React.DOM;
  LikeBar = React.createFactory(LikeBarClass);
  ResolveButton = React.createFactory(ResolveButtonClass);
  TimeCounter = React.createFactory(TimeCounterClass);
  AnnotationButton = React.createFactory(AnnotationButtonClass);
  CommentActivityUI = React.createClass({
    propTypes: {
      context_activity_store: React.PropTypes.object.isRequired,
      comment_activity: React.PropTypes.object.isRequired,
      update_resolved: React.PropTypes.func.isRequired,
      delete_comment: React.PropTypes.func.isRequired,
      user: React.PropTypes.object.isRequired,
      onLikeComment: React.PropTypes.func,
      onAnnotationButtonMouseUp: React.PropTypes.func,
      fileViewerState: React.PropTypes.object,
      shouldAutoLinkify: React.PropTypes.bool,
      shouldUseSimpleModals: React.PropTypes.bool,
      shouldHidePhotoAvatars: React.PropTypes.bool
    },
    getDefaultProps: function() {
      return {
        shouldAutoLinkify: true,
        shouldUseSimpleModals: false,
        shouldHidePhotoAvatars: false
      };
    },
    getInitialState: function() {
      return {
        hover: false
      };
    },
    onAnnotationButtonMouseUp: function(event) {
      var comment, _base;
      comment = this.props.comment_activity.comment;
      return typeof (_base = this.props).onAnnotationButtonMouseUp === "function" ? _base.onAnnotationButtonMouseUp(this.props.comment_activity, comment.comment_metadata) : void 0;
    },
    updateResolved: function(resolved) {
      return this.props.update_resolved(this.props.comment_activity, resolved);
    },
    deleteComment: function(e) {
      var style;
      style = this.props.shouldUseSimpleModals ? "simple" : "default";
      e.preventDefault();
      return SimpleModal.show({
        title_text: i18n._("Delete comment?"),
        body_html: i18n._("Are you sure you want to delete this comment?"),
        cancel_text: i18n._("Cancel"),
        confirm_text: i18n._("Delete"),
        style: style,
        confirm_callback: (function(_this) {
          return function() {
            return _this.props.delete_comment(_this.props.comment_activity);
          };
        })(this)
      });
    },
    onLikeComment: function() {
      var _base;
      return typeof (_base = this.props).onLikeComment === "function" ? _base.onLikeComment(this.props.comment_activity) : void 0;
    },
    _isCommentForOldRevision: function() {
      var revision;
      if ((this.props.fileViewerState != null) && this.props.comment_activity.comment.has_metadata()) {
        revision = this.props.comment_activity.comment.comment_metadata.revision;
        return (revision != null) && this.props.fileViewerState.isOldRevision(revision);
      }
      return false;
    },
    _renderAnnotationMarkerLocation: function(comment_metadata) {
      var annotation, revision;
      annotation = Annotation.createAnnotationFromDict(comment_metadata.annotation);
      revision = comment_metadata.revision;
      return AnnotationButton({
        revision: revision,
        annotation: annotation,
        isOldRevision: this._isCommentForOldRevision(),
        onAnnotationButtonMouseUp: this.onAnnotationButtonMouseUp
      });
    },
    renderPhoto: function() {
      var avatar, avatar_props, _ref;
      avatar_props = {
        dimension: 32,
        defaultAvatar: new InitialsAvatar({
          dimension: 32,
          shape: 'CIRCLE',
          initials: this.props.comment_activity.comment.commenter.initials
        }),
        key: this.props.comment_activity.comment.commenter.id
      };
      if (!this.props.shouldHidePhotoAvatars) {
        avatar_props["photoUrl"] = this.props.comment_activity.comment.commenter.photo_circle_url;
      }
      if (_ref = this.props.comment_activity.comment.commenter.id, __indexOf.call(Viewer.get_viewer().get_user_ids(true), _ref) >= 0) {
        avatar = new ViewerAvatar(avatar_props);
      } else {
        avatar = new AvatarWithDefault(avatar_props);
      }
      return d.div({
        className: "commenter-photo"
      }, avatar);
    },
    renderCommentBody: function() {
      var comment_segment, line_break_reg, mentions_capture_reg, mentions_reg, name, parsed_comment, r, regexes, split_reg, tokens, url, url_full_match, url_reg, url_sub_match, _i, _len, _ref;
      mentions_reg = /@\[(?:\s*(?:dbid:)?[^:\[\]]+):(?:[^\[]+)\]/i;
      mentions_capture_reg = /@\[(\s*(?:dbid:)?[^:\[\]]+):([^\[]+)\]/i;
      url_sub_match = "(?:[-a-zA-Z0-9@:%_+~#=]+[.])+[a-z]{2,6}(?:[:./?#][-a-zA-Z0-9@%_+~&=]+)*(?=[^a-zA-Z0-9_]|$)";
      url_full_match = "http://" + url_sub_match + "|https://" + url_sub_match + "|www." + url_sub_match + "|" + url_sub_match;
      url_reg = new RegExp(url_full_match, "i");
      line_break_reg = /\n/;
      regexes = [mentions_reg, line_break_reg];
      if (this.props.shouldAutoLinkify) {
        regexes.push(url_reg);
      }
      split_reg = RegExp("(" + ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = regexes.length; _i < _len; _i++) {
          r = regexes[_i];
          _results.push(r.source);
        }
        return _results;
      })()).join("|") + ")", "gi");
      parsed_comment = [];
      _ref = this.props.comment_activity.comment.raw_comment_text.split(split_reg);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        comment_segment = _ref[_i];
        if (!comment_segment) {
          continue;
        }
        if (comment_segment.match(mentions_reg)) {
          tokens = comment_segment.match(mentions_capture_reg);
          name = tokens[2].trim();
          parsed_comment.push(d.span({
            className: "comment-mention"
          }, name));
        } else if (__indexOf.call(regexes, url_reg) >= 0 && comment_segment.match(url_reg)) {
          url = comment_segment;
          if (url.indexOf("http://") < 0 && url.indexOf("https://") < 0) {
            url = "http://" + url;
          }
          url = ReferrerCleansingRedirect.get_redirect_uri(url);
          parsed_comment.push(d.a({
            href: url,
            target: "_blank"
          }, comment_segment));
        } else if (comment_segment.match(line_break_reg)) {
          parsed_comment.push(d.br({}));
        } else {
          parsed_comment.push(comment_segment);
        }
      }
      return parsed_comment;
    },
    renderBody: function() {
      var can_see_delete, comment, deleteButton, deleteIcon, dot, metadataAnnotationUI;
      dot = d.div({
        className: "second-bottom-dot",
        dangerouslySetInnerHTML: {
          __html: "&middot;"
        }
      });
      deleteIcon = d.div({
        className: "delete-icon",
        onMouseDown: ((function(_this) {
          return function(e) {
            return _this.deleteComment(e);
          };
        })(this))
      }, i18n._("Delete"));
      deleteButton = [];
      deleteButton.push(dot);
      deleteButton.push(deleteIcon);
      can_see_delete = this.state.hover;
      if (!$u.intersection(Viewer.get_viewer().get_user_ids(true), this.props.comment_activity.permissions.user_ids_who_can_delete).length) {
        can_see_delete = false;
      }
      comment = this.props.comment_activity.comment;
      if (comment.has_metadata()) {
        if (comment.comment_metadata.has_annotation_data()) {
          metadataAnnotationUI = d.div({
            className: "comment-annotation"
          }, this._renderAnnotationMarkerLocation(comment.comment_metadata));
        }
      }
      return d.div({
        className: "comment-body"
      }, d.div({
        className: "comment-top-bar"
      }, d.div({
        className: "commenter-name"
      }, comment.commenter.display_name), this.props.user.is_signed_in ? (this.state.hover && !comment.resolved) || comment.resolved ? ResolveButton({
        resolved: comment.resolved,
        update_resolved: this.updateResolved
      }) : void 0 : void 0), comment.has_metadata() && comment.comment_metadata.has_sticker_data() ? d.div({
        className: "comment-sticker-body"
      }, d.img({
        src: StickerUtil.getStickerImageUrl(comment.comment_metadata.get_sticker_id())
      })) : d.div({
        className: "comment-text"
      }, this.renderCommentBody()), metadataAnnotationUI, d.div({
        className: "comment-bottom-bar"
      }, LikeBar({
        activity: this.props.comment_activity,
        context_activity_store: this.props.context_activity_store,
        user: this.props.user,
        onLikeComment: this.onLikeComment
      }), d.div({
        className: "bottom-dot",
        dangerouslySetInnerHTML: {
          __html: "&middot;"
        }
      }), TimeCounter({
        when_mses: comment.when_mses
      }), can_see_delete ? deleteButton : void 0));
    },
    render: function() {
      var classes;
      classes = React.addons.classSet({
        "comment": true,
        "resolved": this.props.comment_activity.comment.resolved,
        "comment--old-revision": this._isCommentForOldRevision()
      });
      return d.div({
        className: "comment-activity",
        "data-comment-activity-key": this.props.comment_activity.activity_key,
        onMouseMove: ((function(_this) {
          return function(e) {
            return _this.setState({
              hover: true
            });
          };
        })(this)),
        onMouseLeave: ((function(_this) {
          return function(e) {
            return _this.setState({
              hover: false
            });
          };
        })(this))
      }, d.div({
        className: classes
      }, this.renderPhoto(), this.renderBody()));
    }
  });
  return CommentActivityUI;
});

//# sourceMappingURL=comment_activity_ui.map
