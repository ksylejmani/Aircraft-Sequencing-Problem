// Generated by CoffeeScript 1.7.1
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

define(['jquery', 'external/react', 'external/underscore', 'modules/core/browser', 'modules/core/exception', 'modules/core/i18n', 'modules/core/notify', 'modules/clean/activity/activity_user', 'modules/clean/contacts/types', 'modules/clean/contacts/util', 'modules/clean/gandalf_util', 'modules/clean/keycode', 'modules/clean/storage', 'modules/clean/react/activity/mentions_controller', 'modules/clean/react/activity/users_to_notify', 'modules/clean/react/button', 'modules/clean/react/tooltip', 'modules/clean/avatar/components', 'modules/clean/viewer', 'modules/clean/react/file_comments/logger', 'modules/clean/react/sprite', 'modules/clean/react/react_i18n', 'modules/clean/react/file_comments/stickers', 'modules/clean/react/bubble_dropdown'], function($j, React, $u, Browser, JSException, _arg, Notify, ActivityUser, ContactTypes, ContactsUtil, GandalfUtil, KeyCode, _arg1, MentionsControllerClass, UsersToNotifyClass, button, tooltip, _arg2, Viewer, FileActivityClientLogger, sprite, _arg3, _arg4, BubbleDropdown) {
  var AvatarWithDefault, CommentInput, InitialsAvatar, LocalStorage, MentionsController, R_, ReactCSSTransitionGroup, Stickers, UsersToNotify, ViewerAvatar, d, ungettext, _;
  _ = _arg._, ungettext = _arg.ungettext;
  LocalStorage = _arg1.LocalStorage;
  AvatarWithDefault = _arg2.AvatarWithDefault, InitialsAvatar = _arg2.InitialsAvatar, ViewerAvatar = _arg2.ViewerAvatar;
  R_ = _arg3.R_;
  Stickers = _arg4.Stickers;
  d = React.DOM;
  ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;
  MentionsController = React.createFactory(MentionsControllerClass);
  UsersToNotify = React.createFactory(UsersToNotifyClass);
  CommentInput = React.createClass({
    propTypes: {
      activity: React.PropTypes.object.isRequired,
      commentCallback: React.PropTypes.func,
      resizeCallback: React.PropTypes.func,
      positionDropdownCallback: React.PropTypes.func,
      onFocus: React.PropTypes.func,
      onBlur: React.PropTypes.func,
      user: React.PropTypes.object.isRequired,
      onShowNewComment: React.PropTypes.func,
      inBlankState: React.PropTypes.bool,
      enableNotifyText: React.PropTypes.bool,
      enableNoNotifyHint: React.PropTypes.bool,
      showNewComment: React.PropTypes.bool,
      popupsShouldDropdown: React.PropTypes.bool,
      verifyAfterSignUpCallback: React.PropTypes.func,
      initialText: React.PropTypes.string,
      shouldInitiallyFocusInput: React.PropTypes.bool,
      shouldAlwaysInEditMode: React.PropTypes.bool,
      isCommentInputDisabled: React.PropTypes.bool,
      enableStickers: React.PropTypes.bool,
      onAddSticker: React.PropTypes.func,
      contactSearchLogger: React.PropTypes.object,
      enableImport: React.PropTypes.bool,
      shouldHidePhotoAvatars: React.PropTypes.bool
    },
    getInitialState: function() {
      var button_disabled, initialText, showPostButton, _ref, _ref1;
      button_disabled = true;
      showPostButton = false;
      if (this.props.initialText != null) {
        initialText = this.props.initialText;
      } else {
        initialText = this._getCommentLocalStorage((_ref = this.props.activity) != null ? _ref.activity_key : void 0);
      }
      if (initialText.length > 0) {
        button_disabled = false;
        showPostButton = true;
      }
      return {
        button_disabled: button_disabled,
        showPostButton: showPostButton,
        initialText: initialText,
        users_to_notify: (_ref1 = this.props.activity) != null ? _ref1.users_to_notify : void 0,
        commentMetadata: null,
        enableStickers: false
      };
    },
    getDefaultProps: function() {
      return {
        onShowNewComment: $j.noop,
        shouldAlwaysInEditMode: false,
        isCommentInputDisabled: false,
        enableImport: true,
        shouldHidePhotoAvatars: false
      };
    },
    componentDidMount: function() {
      var componentWasClicked;
      componentWasClicked = function(event, comp) {
        var node;
        node = (comp != null ? comp.getDOMNode() : void 0) || null;
        if (node) {
          return event.target === node || $j.contains(node, event.target);
        }
        return false;
      };
      $j(this.getDOMNode()).on('click.comment-input', (function(_this) {
        return function(event) {
          if (componentWasClicked(event, _this.refs.postButton)) {
            _this.verifySubscribersBeforePost();
          }
          if (componentWasClicked(event, _this.refs.showNewCommentButton)) {
            return _this.props.onShowNewComment();
          }
        };
      })(this));
      if (this._wasUsedLoggedOutPreviously() && this.props.user.is_signed_in) {
        if (this.props.user.is_email_verified) {
          if (Browser.mozilla != null) {
            return setTimeout((function(_this) {
              return function() {
                return _this.postComment();
              };
            })(this), 0);
          } else {
            return this.postComment();
          }
        } else {
          return this.props.verifyAfterSignUpCallback();
        }
      }
    },
    componentWillUnmount: function() {
      return $j(this.getDOMNode()).off('.comment-input');
    },
    componentWillReceiveProps: function(nextProps) {
      return this.updateNotificationCount(nextProps.activity);
    },
    _contactsSelectorPopupShown: function() {
      return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_CONTACT_LIST_SHOWN, this.props.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.LITTLE_MAN_BUTTON, this.props.user.id);
    },
    _onAtSignKeyPress: function() {
      if (this.props.user.is_signed_in) {
        return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_CONTACT_LIST_SHOWN, this.props.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.AT_SIGN_KEYPRESS, this.props.user.id);
      }
    },
    _onNoAtSignKeyPress: function() {
      return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_CONTACT_LIST_SHOWN, this.props.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.NO_AT_SIGN_KEYPRESS, this.props.user.id);
    },
    _contactPopupSelectedCallback: function() {
      JSException.assert(this.props.user.is_signed_in, "Contact selected from popup when user is logged out");
      return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_CONTACT_LIST_SELECTED, this.props.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.LITTLE_MAN_BUTTON, this.props.user.id);
    },
    _contactSelectedCallback: function(isNoAtSignPressed) {
      var eventOrigin;
      JSException.assert(this.props.user.is_signed_in, "Contact selected when user is logged out");
      if (isNoAtSignPressed) {
        eventOrigin = Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.NO_AT_SIGN_KEYPRESS;
      } else {
        eventOrigin = Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.AT_SIGN_KEYPRESS;
      }
      return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_CONTACT_LIST_SELECTED, this.props.activity.activity_key, null, eventOrigin, this.props.user.id);
    },
    _stickerPopupShownCallback: function() {
      return FileActivityClientLogger.log_event(Constants.FILE_ACTIVITY_LOG_EVENT_TYPE.CLIENT_STICKERS_SHOWN, this.props.activity.activity_key, null, Constants.FILE_ACTIVITY_LOG_CLIENT_ORIGIN_TYPE.STICKER_BUTTON, this.props.user.id);
    },
    onMentionsFocus: function(event) {
      var _base;
      this.togglePostButton(true);
      return typeof (_base = this.props).onFocus === "function" ? _base.onFocus(event) : void 0;
    },
    onMentionsBlur: function(event) {
      var _base;
      if (typeof (_base = this.props).onBlur === "function") {
        _base.onBlur();
      }
      if (!this.refs.mentions.getEncodedMessage()) {
        if (!this.props.shouldAlwaysInEditMode) {
          return this.togglePostButton(false);
        }
      } else {
        if (this.shouldSaveText()) {
          return this._storeCommentLocalStorage(this.refs.mentions.getRawMessage(), this.props.activity.activity_key);
        }
      }
    },
    onKeyDown: function(event) {
      if (event.keyCode === KeyCode.ENTER && (event.ctrlKey || event.metaKey)) {
        this.verifySubscribersBeforePost();
        return event.preventDefault();
      }
    },
    onKeyUp: function(event) {
      this._setPostButtonState();
      return this.updateNotificationCount(this.props.activity);
    },
    onPaste: function(event) {
      return setTimeout((function(_this) {
        return function() {
          _this._setPostButtonState();
          return _this.updateNotificationCount(_this.props.activity);
        };
      })(this), 10);
    },
    refreshDropdownDirection: function() {
      var _base;
      return typeof (_base = this.props).positionDropdownCallback === "function" ? _base.positionDropdownCallback() : void 0;
    },
    togglePostButton: function(should_show) {
      return this.setState({
        showPostButton: should_show
      }, (function(_this) {
        return function() {
          var _base;
          return typeof (_base = _this.props).resizeCallback === "function" ? _base.resizeCallback() : void 0;
        };
      })(this));
    },
    shouldSaveText: function() {
      return !this.props.user.is_signed_in || !this.props.user.is_email_verified;
    },
    _wasUsedLoggedOutPreviously: function() {
      return this.state.initialText.length > 0 && (this.props.initialText == null);
    },
    updateNotificationCount: function(activity) {
      var combined_ids, current_ids, id, ids_to_add, mention, new_ids, new_mentions, new_mentions_by_id, new_users_to_notify, original_ids, user, _i, _len;
      if ((activity != null ? activity.users_to_notify : void 0) != null) {
        original_ids = (function() {
          var _i, _len, _ref, _results;
          _ref = activity.users_to_notify;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            user = _ref[_i];
            _results.push(user.unique_id);
          }
          return _results;
        })();
        new_mentions = this.refs.mentions.extractMentions();
        new_ids = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = new_mentions.length; _i < _len; _i++) {
            mention = new_mentions[_i];
            _results.push(mention.dbx_account_id || mention.identifier);
          }
          return _results;
        })();
        combined_ids = $u.union(original_ids, new_ids).sort();
        current_ids = $u.pluck(this.state.users_to_notify, "id").sort();
        if ($u.isEqual(current_ids, combined_ids)) {
          return;
        }
        new_mentions_by_id = $u.object(new_ids, new_mentions);
        ids_to_add = $u.difference(combined_ids, original_ids);
        new_users_to_notify = $u.clone(activity.users_to_notify);
        for (_i = 0, _len = ids_to_add.length; _i < _len; _i++) {
          id = ids_to_add[_i];
          new_users_to_notify.push(new ActivityUser({
            id: id,
            display_name: new_mentions_by_id[id].name
          }));
        }
        return this.setState({
          users_to_notify: new_users_to_notify
        });
      }
    },
    setCursorToEndOfInput: function() {
      return this.refs.mentions.setCursorToEndOfInput();
    },
    _onSkipAddMention: function(event) {
      return this.postComment();
    },
    _setPostButtonState: function() {
      var is_disabled;
      is_disabled = this.refs.mentions.getEncodedMessage() === "";
      if (this.state.button_disabled !== is_disabled) {
        return this.setState({
          button_disabled: is_disabled
        });
      }
    },
    verifySubscribersBeforePost: function(event) {
      var filtered_users, user, _ref, _ref1;
      if (this.props.user.is_signed_in) {
        filtered_users = (function() {
          var _i, _len, _ref, _results;
          _ref = this.state.users_to_notify;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            user = _ref[_i];
            if (user.id !== this.props.user.id) {
              _results.push(user);
            }
          }
          return _results;
        }).call(this);
        if (filtered_users.length === 0 && ((_ref = this.props.activity.comment_activities) != null ? _ref.length : void 0) === 0 && this.props.enableNoNotifyHint) {
          if ((_ref1 = this.refs.mentions) != null) {
            _ref1.showNoNotifyHint();
          }
          return;
        }
      }
      return this.postComment();
    },
    postComment: function() {
      var comment_text, _base;
      comment_text = this.refs.mentions.getEncodedMessage();
      if (!comment_text) {
        return;
      }
      if (!this.shouldSaveText()) {
        this.refs.mentions.disableMentions();
        this.refs.mentions.clearTextField();
        this._setPostButtonState();
        this.togglePostButton(false);
      }
      return typeof (_base = this.props).commentCallback === "function" ? _base.commentCallback(comment_text) : void 0;
    },
    _postSticker: function(id) {
      var _base, _ref;
      if (typeof (_base = this.props).onAddSticker === "function") {
        _base.onAddSticker(id);
      }
      return (_ref = this.refs.stickerDropdown) != null ? _ref.hide() : void 0;
    },
    focusInput: function() {
      var _ref;
      return (_ref = this.refs.mentions) != null ? _ref.focusInput() : void 0;
    },
    getRawCommentInput: function() {
      var _ref;
      return (_ref = this.refs.mentions) != null ? _ref.getRawMessage() : void 0;
    },
    getPlaceholderText: function() {
      return this.placeholderText;
    },
    _usersToNotifyToContacts: function(users_to_notify) {
      var contacts, user, _i, _len;
      contacts = [];
      for (_i = 0, _len = users_to_notify.length; _i < _len; _i++) {
        user = users_to_notify[_i];
        if (user.id === this.props.user.id) {
          continue;
        }
        contacts.push(ContactsUtil.activityUserToContact(user, Number.MAX_VALUE));
      }
      return contacts;
    },
    _clearCommentLocalStorage: function(activity_key) {
      return LocalStorage.set("tmp-file-comment", null);
    },
    _getCommentLocalStorage: function(activity_key) {
      var comment_text, local_store;
      local_store = LocalStorage.get("tmp-file-comment");
      comment_text = "";
      if (local_store && local_store.activity_key === activity_key) {
        if ((new Date().getTime()) - local_store.time < (1000 * 60 * 5)) {
          comment_text = local_store.text;
        }
        this._clearCommentLocalStorage();
      }
      return $j('<div/>').html(comment_text).text();
    },
    _storeCommentLocalStorage: function(value, activity_key) {
      var text;
      text = $j('<div/>').text(value).html();
      return LocalStorage.set("tmp-file-comment", {
        activity_key: activity_key,
        text: text,
        time: new Date().getTime()
      });
    },
    _renderShowNewComment: function() {
      var newComment, showNewCommentViews;
      showNewCommentViews = [];
      if (this.props.showNewComment) {
        newComment = d.a({
          className: "show-new-comment-button",
          ref: "showNewCommentButton"
        }, [
          d.span({
            className: "show-new-comment-icon"
          }), d.span({
            className: "show-new-comment-text"
          }, _("New Comment"))
        ]);
        showNewCommentViews = d.div({
          className: "comment-show-new-comment"
        }, newComment);
      }
      return ReactCSSTransitionGroup({
        transitionName: "comment-show-new-comment",
        component: d.div
      }, showNewCommentViews);
    },
    _renderCommentBox: function() {
      var extra_contacts, mentionsController;
      if (this.props.inBlankState) {
        this.placeholderText = _("Write a comment");
      } else {
        this.placeholderText = _("Comment or @mention");
      }
      extra_contacts = this.props.activity != null ? this.props.activity.users_to_notify : [];
      mentionsController = MentionsController({
        ref: "mentions",
        placeholder_text: this.placeholderText,
        initialText: this.state.initialText,
        contacts_should_dropdown: this.props.popupsShouldDropdown,
        contactSearchLogger: this.props.contactSearchLogger,
        shouldInitiallyFocusInput: this.props.shouldInitiallyFocusInput,
        shouldAlwaysInEditMode: this.props.shouldAlwaysInEditMode,
        onFocus: this.onMentionsFocus,
        onBlur: this.onMentionsBlur,
        position_contacts_callback: this.props.positionDropdownCallback,
        resizeCallback: this.props.resizeCallback,
        onKeyUp: this.onKeyUp,
        onKeyDown: this.onKeyDown,
        onPaste: this.onPaste,
        onMention: (function(_this) {
          return function() {
            return _this.updateNotificationCount(_this.props.activity);
          };
        })(this),
        user: this.props.user,
        showMentionsHelper: GandalfUtil.getGandalfRule("dw-comments-add-mention-dropdown") && this.props.user.is_signed_in,
        enableNoAtMentions: GandalfUtil.getGandalfRule("dw-comments-no-at-mentions") && this.props.user.is_signed_in,
        contactsSelectorPopupShown: this._contactsSelectorPopupShown,
        onAtSignKeyPress: this._onAtSignKeyPress,
        onNoAtSignKeyPress: this._onNoAtSignKeyPress,
        contactPopupSelectedCallback: this._contactPopupSelectedCallback,
        contactSelectedCallback: this._contactSelectedCallback,
        onSkipAddMention: this._onSkipAddMention,
        enableImport: this.props.enableImport,
        extraContacts: this._usersToNotifyToContacts(extra_contacts),
        shouldHidePhotoAvatars: this.props.shouldHidePhotoAvatars
      });
      return d.div({
        className: "comment-box"
      }, [
        d.div({
          className: "mention-sticker-container"
        }, [mentionsController, this.props.enableStickers ? this._renderStickerButton() : void 0]), d.div({
          className: "post-area",
          ref: "postArea"
        }, [this.props.enableNotifyText ? this._renderTooltipContainer() : void 0, this._renderButtonContainer()])
      ]);
    },
    _renderCommenterPhoto: function() {
      var photo, photo_props, _ref, _ref1;
      photo_props = {
        dimension: 32,
        defaultAvatar: new InitialsAvatar({
          dimension: 32,
          shape: 'CIRCLE',
          initials: this.props.user.initials || '?'
        })
      };
      if (!this.props.shouldHidePhotoAvatars) {
        photo_props["photoUrl"] = this.props.user.photo_circle_url;
      }
      if (_ref = (_ref1 = this.props.user) != null ? _ref1.id : void 0, __indexOf.call(Viewer.get_viewer().get_user_ids(true), _ref) >= 0) {
        photo = new ViewerAvatar(photo_props);
      } else {
        photo = new AvatarWithDefault(photo_props);
      }
      return d.div({
        className: "commenter-photo"
      }, photo);
    },
    _renderTooltipContainer: function() {
      return d.div({
        className: "tooltip-container"
      }, UsersToNotify({
        usersToNotify: this.state.users_to_notify,
        user: this.props.user,
        show_extra_text: !this.state.showPostButton
      }));
    },
    _renderStickerButton: function() {
      var stickerBubbleDirection, stickerVerticalDisplacement, sticker_bubble_target;
      sticker_bubble_target = d.a({
        className: "comment-sticker-add",
        onMouseUp: this._stickerPopupShownCallback
      }, sprite({
        group: "web",
        name: "s_rainbow"
      }));
      stickerBubbleDirection = this.props.popupsShouldDropdown ? "top" : "bottom";
      stickerVerticalDisplacement = this.props.popupsShouldDropdown ? 4 : -11;
      return d.div({
        className: "comment-sticker-button",
        onMouseDown: this.refreshDropdownDirection
      }, BubbleDropdown({
        target: sticker_bubble_target,
        ref: "stickerDropdown",
        arrow_position: "" + stickerBubbleDirection + "-right",
        vertical_displacement: stickerVerticalDisplacement,
        extra_css_class: "stickers-bubble-dropdown",
        horizontal_displacement: 1,
        anchor_bottom: !this.props.popupsShouldDropdown
      }, Stickers({
        isPopupAbove: this.props.popupsShouldDropdown,
        onStickerSelected: this._postSticker
      })));
    },
    _renderButtonContainer: function() {
      var attrs, isDisabled, isHidden, postButton;
      isHidden = !this.state.showPostButton;
      isDisabled = this.state.button_disabled;
      attrs = {
        className: "post-button",
        disabled: isDisabled,
        ref: 'postButton'
      };
      postButton = button.button(attrs, _("Post"));
      return d.div({
        className: "button-container",
        hidden: isHidden
      }, postButton);
    },
    render: function() {
      var comment_field_classes;
      comment_field_classes = React.addons.classSet({
        "comment-field": true,
        "comment-expanded": GandalfUtil.getGandalfRule("dw-comments-expanded-input") && (this.state.showPostButton || this.props.inBlankState),
        "comment-field--disabled": this.props.isCommentInputDisabled
      });
      return d.div({
        className: comment_field_classes
      }, [
        this._renderShowNewComment(), this._renderCommenterPhoto(), this._renderCommentBox(), this.props.isCommentInputDisabled ? d.div({
          className: "comment-field__diabled"
        }, "") : void 0
      ]);
    }
  });
  return CommentInput;
});

//# sourceMappingURL=comment_input.map
